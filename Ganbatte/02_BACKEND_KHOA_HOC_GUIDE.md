# üü¢ BACKEND - LU·ªíNG KH√ìA H·ªåC H∆Ø·ªöNG D·∫™N CHI TI·∫æT

## üéØ TR√ÅCH NHI·ªÜM C·ª¶A B·∫†N

B·∫°n ch·ªãu tr√°ch nhi·ªám v·ªÅ **to√†n b·ªô h·ªá th·ªëng qu·∫£n l√Ω kh√≥a h·ªçc** trong h·ªá th·ªëng, bao g·ªìm:
- Qu·∫£n l√Ω kh√≥a h·ªçc (Courses) - CRUD operations
- ƒêƒÉng k√Ω kh√≥a h·ªçc (Course Registrations)
- N·ªôi dung kh√≥a h·ªçc (Course Content & Lessons)
- Ti·∫øn ƒë·ªô h·ªçc t·∫≠p (Course Progress)
- T√≠ch h·ª£p thanh to√°n VNPay

## üìÅ C√ÅC FILE B·∫†N C·∫¶N N·∫ÆMƒê∆Ø·ª¢C

### üéÆ **CONTROLLERS (API Endpoints)**

#### **1. CourseController.java**
**ƒê∆∞·ªùng d·∫´n:** `backend/src/main/java/com/drugprevention/drugbe/controller/CourseController.java`

**Ch·ª©c nƒÉng ch√≠nh:**
```java
// API endpoints m√† b·∫°n qu·∫£n l√Ω:
GET    /api/courses                    // L·∫•y danh s√°ch kh√≥a h·ªçc (public)
POST   /api/courses                    // T·∫°o kh√≥a h·ªçc m·ªõi (STAFF+)
GET    /api/courses/{id}               // Chi ti·∫øt kh√≥a h·ªçc
PUT    /api/courses/{id}               // C·∫≠p nh·∫≠t kh√≥a h·ªçc (STAFF+)
DELETE /api/courses/{id}               // X√≥a kh√≥a h·ªçc (ADMIN+)
GET    /api/courses/category/{categoryId}  // Kh√≥a h·ªçc theo danh m·ª•c
GET    /api/courses/featured           // Kh√≥a h·ªçc n·ªïi b·∫≠t
GET    /api/courses/search             // T√¨m ki·∫øm kh√≥a h·ªçc
```

**Ph√¢n quy·ªÅn quan tr·ªçng:**
```java
// Public endpoints (kh√¥ng c·∫ßn auth)
@GetMapping - Browse courses

// STAFF, ADMIN, MANAGER only
@PostMapping - Create course
@PutMapping - Update course

// ADMIN, MANAGER only  
@DeleteMapping - Delete course
```

#### **2. CourseRegistrationController.java**
**ƒê∆∞·ªùng d·∫´n:** `backend/src/main/java/com/drugprevention/drugbe/controller/CourseRegistrationController.java`

**Ch·ª©c nƒÉng ch√≠nh:**
```java
// API endpoints cho ƒëƒÉng k√Ω kh√≥a h·ªçc:
POST   /api/course-registrations/register/{courseId}     // ƒêƒÉng k√Ω kh√≥a h·ªçc
GET    /api/course-registrations/my-courses              // Kh√≥a h·ªçc c·ªßa user
GET    /api/course-registrations/course/{courseId}       // Danh s√°ch h·ªçc vi√™n
PUT    /api/course-registrations/{id}/progress           // C·∫≠p nh·∫≠t ti·∫øn ƒë·ªô
DELETE /api/course-registrations/{id}                    // H·ªßy ƒëƒÉng k√Ω
GET    /api/course-registrations/{id}/certificate        // L·∫•y ch·ª©ng ch·ªâ
```

#### **3. StaffCourseController.java**  
**ƒê∆∞·ªùng d·∫´n:** `backend/src/main/java/com/drugprevention/drugbe/controller/StaffCourseController.java`

**Ch·ª©c nƒÉng ch√≠nh:**
```java
// API endpoints cho staff qu·∫£n l√Ω:
GET    /api/staff/courses                    // Kh√≥a h·ªçc do staff qu·∫£n l√Ω
POST   /api/staff/courses                    // T·∫°o kh√≥a h·ªçc m·ªõi
PUT    /api/staff/courses/{id}               // C·∫≠p nh·∫≠t kh√≥a h·ªçc
GET    /api/staff/courses/{id}/students      // Danh s√°ch h·ªçc vi√™n
GET    /api/staff/courses/{id}/statistics    // Th·ªëng k√™ kh√≥a h·ªçc
POST   /api/staff/courses/{id}/content       // Th√™m n·ªôi dung
PUT    /api/staff/courses/content/{contentId} // S·ª≠a n·ªôi dung
DELETE /api/staff/courses/content/{contentId} // X√≥a n·ªôi dung
```

### ‚öôÔ∏è **SERVICES (Business Logic)**

#### **CourseService.java**
**ƒê∆∞·ªùng d·∫´n:** `backend/src/main/java/com/drugprevention/drugbe/service/CourseService.java`

**C√°c method quan tr·ªçng:**

```java
// T·∫°o kh√≥a h·ªçc m·ªõi
public Course createCourse(Course course) {
    // 1. Validate course data
    validateCourseData(course);
    
    // 2. Set default values
    course.setCurrentParticipants(0);
    course.setStatus("open");
    course.setIsFeatured(false);
    course.setTotalReviews(0);
    course.setCreatedAt(LocalDateTime.now());
    
    // 3. Save to database
    Course saved = courseRepository.save(course);
    
    // 4. Create default course content structure
    createDefaultCourseStructure(saved);
    
    return saved;
}

// C·∫≠p nh·∫≠t kh√≥a h·ªçc
public Course updateCourse(Long id, Course courseUpdate) {
    // 1. Check course exists
    Course existing = courseRepository.findById(id)
        .orElseThrow(() -> new RuntimeException("Course not found"));
    
    // 2. Check permission (ch·ªâ instructor ho·∫∑c admin)
    validateUpdatePermission(existing, getCurrentUser());
    
    // 3. Update fields
    updateCourseFields(existing, courseUpdate);
    
    // 4. Save changes
    return courseRepository.save(existing);
}

// T√¨m ki·∫øm kh√≥a h·ªçc
public Page<Course> searchCourses(String query, String category, 
                                  String level, BigDecimal maxPrice, Pageable pageable) {
    // 1. Build search criteria
    CourseSearchCriteria criteria = CourseSearchCriteria.builder()
        .query(query)
        .category(category)
        .level(level)
        .maxPrice(maxPrice)
        .status("open")
        .build();
    
    // 2. Execute search v·ªõi Specification
    return courseRepository.findAll(buildSpecification(criteria), pageable);
}

// L·∫•y kh√≥a h·ªçc n·ªïi b·∫≠t
public List<Course> getFeaturedCourses() {
    return courseRepository.findByIsFeaturedTrueAndStatusOrderByCreatedAtDesc("open");
}
```

**Validation Rules quan tr·ªçng:**
```java
private void validateCourseData(Course course) {
    // 1. Title validation
    if (course.getTitle() == null || course.getTitle().trim().isEmpty()) {
        throw new ValidationException("Course title is required");
    }
    
    // 2. Price validation  
    if (course.getPrice() != null && course.getPrice().compareTo(BigDecimal.ZERO) < 0) {
        throw new ValidationException("Course price cannot be negative");
    }
    
    // 3. Duration validation
    if (course.getDurationWeeks() != null && course.getDurationWeeks() <= 0) {
        throw new ValidationException("Duration must be positive");
    }
    
    // 4. Max participants validation
    if (course.getMaxParticipants() != null && course.getMaxParticipants() <= 0) {
        throw new ValidationException("Max participants must be positive");
    }
    
    // 5. Category validation
    if (course.getCategory() != null) {
        categoryRepository.findById(course.getCategory().getId())
            .orElseThrow(() -> new ValidationException("Invalid category"));
    }
}
```

#### **CourseRegistrationService.java**
**ƒê∆∞·ªùng d·∫´n:** `backend/src/main/java/com/drugprevention/drugbe/service/CourseRegistrationService.java`

**C√°c method quan tr·ªçng:**

```java
// ƒêƒÉng k√Ω kh√≥a h·ªçc
@Transactional
public CourseRegistration registerForCourse(Long courseId, String username) {
    // 1. T√¨m user v√† course
    User user = userRepository.findByUsername(username)
        .orElseThrow(() -> new RuntimeException("User not found"));
    Course course = courseRepository.findById(courseId)
        .orElseThrow(() -> new RuntimeException("Course not found"));
    
    // 2. Ki·ªÉm tra ƒëi·ªÅu ki·ªán ƒëƒÉng k√Ω
    validateRegistrationEligibility(user, course);
    
    // 3. Ki·ªÉm tra ƒë√£ ƒëƒÉng k√Ω ch∆∞a
    Optional<CourseRegistration> existing = courseRegistrationRepository
        .findByUserIdAndCourseId(user.getId(), courseId);
    if (existing.isPresent()) {
        throw new RuntimeException("Already registered for this course");
    }
    
    // 4. Ki·ªÉm tra ch·ªó tr·ªëng
    if (course.getCurrentParticipants() >= course.getMaxParticipants()) {
        throw new RuntimeException("Course is full");
    }
    
    // 5. T·∫°o registration
    CourseRegistration registration = new CourseRegistration();
    registration.setUser(user);
    registration.setCourse(course);
    registration.setRegistrationDate(LocalDateTime.now());
    registration.setStatus("active");
    registration.setProgress(0);
    
    // 6. X·ª≠ l√Ω thanh to√°n n·∫øu c·∫ßn
    if (course.getPrice().compareTo(BigDecimal.ZERO) > 0) {
        Payment payment = createCoursePayment(user, course);
        registration.setPayment(payment);
        registration.setStatus("pending_payment");
    }
    
    // 7. Save registration
    CourseRegistration saved = courseRegistrationRepository.save(registration);
    
    // 8. C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng participants
    course.setCurrentParticipants(course.getCurrentParticipants() + 1);
    courseRepository.save(course);
    
    // 9. T·∫°o course progress tracking
    createInitialProgress(saved);
    
    return saved;
}

// C·∫≠p nh·∫≠t ti·∫øn ƒë·ªô h·ªçc t·∫≠p
@Transactional
public CourseRegistration updateProgress(Long registrationId, int newProgress) {
    // 1. T√¨m registration
    CourseRegistration registration = courseRegistrationRepository.findById(registrationId)
        .orElseThrow(() -> new RuntimeException("Registration not found"));
    
    // 2. Validate progress value
    if (newProgress < 0 || newProgress > 100) {
        throw new ValidationException("Progress must be between 0 and 100");
    }
    
    // 3. Check ownership
    String currentUser = getCurrentUsername();
    if (!registration.getUser().getUsername().equals(currentUser)) {
        throw new SecurityException("Cannot update other user's progress");
    }
    
    // 4. Update progress
    registration.setProgress(newProgress);
    registration.setLastAccessDate(LocalDateTime.now());
    
    // 5. Auto-complete n·∫øu ƒë·∫°t 100%
    if (newProgress == 100 && !"completed".equals(registration.getStatus())) {
        registration.setStatus("completed");
        registration.setCompletionDate(LocalDateTime.now());
        
        // Generate certificate
        generateCertificate(registration);
    }
    
    return courseRegistrationRepository.save(registration);
}
```

### üóÉÔ∏è **ENTITIES (Database Models)**

#### **Course.java**
**ƒê∆∞·ªùng d·∫´n:** `backend/src/main/java/com/drugprevention/drugbe/entity/Course.java`

**C·∫•u tr√∫c Entity:**
```java
@Entity
@Table(name = "courses")
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String title;
    
    @Column(length = 2000)
    private String description;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "instructor_id")
    private User instructor;        // Gi·∫£ng vi√™n (STAFF role)
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id")
    private Category category;      // Danh m·ª•c kh√≥a h·ªçc
    
    @Column(precision = 10, scale = 2)
    private BigDecimal price;       // Gi√° kh√≥a h·ªçc
    
    private Integer durationWeeks;  // Th·ªùi l∆∞·ª£ng (tu·∫ßn)
    private Integer maxParticipants; // S·ªë l∆∞·ª£ng t·ªëi ƒëa
    private Integer currentParticipants; // S·ªë l∆∞·ª£ng hi·ªán t·∫°i
    
    private String level;           // BEGINNER/INTERMEDIATE/ADVANCED
    private String status;          // open/closed/cancelled
    private Boolean isFeatured;     // Kh√≥a h·ªçc n·ªïi b·∫≠t
    
    @Column(length = 500)
    private String imageUrl;        // ·∫¢nh thumbnail
    
    private Integer totalReviews;   // S·ªë l∆∞·ª£ng ƒë√°nh gi√°
    private Double averageRating;   // ƒêi·ªÉm trung b√¨nh
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")  
    private LocalDateTime updatedAt;
    
    // One-to-Many relationships
    @OneToMany(mappedBy = "course", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<CourseRegistration> registrations = new ArrayList<>();
    
    @OneToMany(mappedBy = "course", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<CourseContent> contents = new ArrayList<>();
    
    // Getters, setters, constructors...
}
```

#### **CourseRegistration.java**
**ƒê∆∞·ªùng d·∫´n:** `backend/src/main/java/com/drugprevention/drugbe/entity/CourseRegistration.java`

```java
@Entity
@Table(name = "course_registrations")
@IdClass(CourseRegistrationId.class)
public class CourseRegistration {
    @Id
    private Long userId;
    
    @Id  
    private Long courseId;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    @MapsId("userId")
    private User user;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "course_id")
    @MapsId("courseId")  
    private Course course;
    
    @Column(name = "registration_date")
    private LocalDateTime registrationDate;
    
    private String status;          // active/completed/cancelled/pending_payment
    
    private Integer progress;       // 0-100%
    
    @Column(name = "completion_date")
    private LocalDateTime completionDate;
    
    @Column(name = "last_access_date")
    private LocalDateTime lastAccessDate;
    
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "payment_id")
    private Payment payment;        // Thanh to√°n li√™n quan
    
    @Column(length = 500)
    private String certificateUrl;  // Link ch·ª©ng ch·ªâ
    
    // Getters, setters...
}
```

#### **CourseContent.java**
**ƒê∆∞·ªùng d·∫´n:** `backend/src/main/java/com/drugprevention/drugbe/entity/CourseContent.java`

```java
@Entity
@Table(name = "course_contents")
public class CourseContent {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "course_id")
    private Course course;
    
    @Column(nullable = false)
    private String title;
    
    @Column(length = 5000)
    private String content;         // N·ªôi dung text
    
    private String contentType;     // TEXT/VIDEO/DOCUMENT/QUIZ
    
    @Column(length = 500)
    private String mediaUrl;        // Link video/document
    
    private Integer orderIndex;     // Th·ª© t·ª± hi·ªÉn th·ªã
    
    private Integer durationMinutes; // Th·ªùi l∆∞·ª£ng (ph√∫t)
    
    private Boolean isRequired;     // B·∫Øt bu·ªôc ho√†n th√†nh
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    // One-to-Many v·ªõi CourseProgress
    @OneToMany(mappedBy = "content", cascade = CascadeType.ALL)
    private List<CourseProgress> progresses = new ArrayList<>();
}
```

### üíæ **REPOSITORIES (Data Access)**

#### **CourseRepository.java**
**ƒê∆∞·ªùng d·∫´n:** `backend/src/main/java/com/drugprevention/drugbe/repository/CourseRepository.java`

**Custom Query Methods:**
```java
public interface CourseRepository extends JpaRepository<Course, Long>, JpaSpecificationExecutor<Course> {
    
    // T√¨m kh√≥a h·ªçc theo category
    List<Course> findByCategoryIdAndStatusOrderByCreatedAtDesc(Long categoryId, String status);
    
    // T√¨m kh√≥a h·ªçc n·ªïi b·∫≠t
    List<Course> findByIsFeaturedTrueAndStatusOrderByCreatedAtDesc(String status);
    
    // T√¨m kh√≥a h·ªçc theo instructor
    List<Course> findByInstructorIdOrderByCreatedAtDesc(Long instructorId);
    
    // Search kh√≥a h·ªçc theo title ho·∫∑c description
    @Query("SELECT c FROM Course c WHERE c.status = :status AND " +
           "(LOWER(c.title) LIKE LOWER(CONCAT('%', :query, '%')) OR " +
           "LOWER(c.description) LIKE LOWER(CONCAT('%', :query, '%')))")
    Page<Course> searchByTitleOrDescription(@Param("query") String query, 
                                          @Param("status") String status, 
                                          Pageable pageable);
    
    // Th·ªëng k√™ kh√≥a h·ªçc theo th√°ng
    @Query("SELECT MONTH(c.createdAt) as month, COUNT(c) as count " +
           "FROM Course c WHERE YEAR(c.createdAt) = :year " +
           "GROUP BY MONTH(c.createdAt)")
    List<Object[]> getCourseStatsByMonth(@Param("year") int year);
    
    // Top kh√≥a h·ªçc c√≥ nhi·ªÅu ƒëƒÉng k√Ω nh·∫•t
    @Query("SELECT c FROM Course c WHERE c.status = 'open' " +
           "ORDER BY c.currentParticipants DESC")
    List<Course> findTopPopularCourses(Pageable pageable);
    
    // Kh√≥a h·ªçc c√≥ gi√° trong kho·∫£ng
    List<Course> findByStatusAndPriceBetweenOrderByPriceAsc(String status, 
                                                          BigDecimal minPrice, 
                                                          BigDecimal maxPrice);
    
    // Custom query v·ªõi Specification ƒë·ªÉ search ph·ª©c t·∫°p
    @Query("SELECT c FROM Course c WHERE " +
           "(:title IS NULL OR LOWER(c.title) LIKE LOWER(CONCAT('%', :title, '%'))) AND " +
           "(:categoryId IS NULL OR c.category.id = :categoryId) AND " +
           "(:level IS NULL OR c.level = :level) AND " +
           "(:maxPrice IS NULL OR c.price <= :maxPrice) AND " +
           "c.status = 'open'")
    Page<Course> findCoursesWithFilters(@Param("title") String title,
                                       @Param("categoryId") Long categoryId,
                                       @Param("level") String level,
                                       @Param("maxPrice") BigDecimal maxPrice,
                                       Pageable pageable);
}
```

#### **CourseRegistrationRepository.java**
**ƒê∆∞·ªùng d·∫´n:** `backend/src/main/java/com/drugprevention/drugbe/repository/CourseRegistrationRepository.java`

```java
public interface CourseRegistrationRepository extends JpaRepository<CourseRegistration, CourseRegistrationId> {
    
    // T√¨m registration theo user v√† course
    Optional<CourseRegistration> findByUserIdAndCourseId(Long userId, Long courseId);
    
    // L·∫•y t·∫•t c·∫£ kh√≥a h·ªçc c·ªßa user
    List<CourseRegistration> findByUserIdOrderByRegistrationDateDesc(Long userId);
    
    // L·∫•y danh s√°ch h·ªçc vi√™n c·ªßa kh√≥a h·ªçc
    Page<CourseRegistration> findByCourseIdOrderByRegistrationDateDesc(Long courseId, Pageable pageable);
    
    // ƒê·∫øm s·ªë h·ªçc vi√™n c·ªßa kh√≥a h·ªçc
    Long countByCourseIdAndStatus(Long courseId, String status);
    
    // L·∫•y kh√≥a h·ªçc ho√†n th√†nh c·ªßa user
    List<CourseRegistration> findByUserIdAndStatusOrderByCompletionDateDesc(Long userId, String status);
    
    // Th·ªëng k√™ ƒëƒÉng k√Ω theo th·ªùi gian
    @Query("SELECT DATE(cr.registrationDate) as date, COUNT(cr) as count " +
           "FROM CourseRegistration cr WHERE cr.course.id = :courseId " +
           "AND cr.registrationDate >= :startDate " +
           "GROUP BY DATE(cr.registrationDate) ORDER BY date")
    List<Object[]> getRegistrationStatsByDate(@Param("courseId") Long courseId, 
                                            @Param("startDate") LocalDateTime startDate);
    
    // Top users theo s·ªë kh√≥a h·ªçc ho√†n th√†nh
    @Query("SELECT cr.user, COUNT(cr) as completedCourses " +
           "FROM CourseRegistration cr WHERE cr.status = 'completed' " +
           "GROUP BY cr.user ORDER BY completedCourses DESC")
    List<Object[]> getTopUsersbyCompletedCourses(Pageable pageable);
    
    // T√≠nh completion rate c·ªßa kh√≥a h·ªçc
    @Query("SELECT " +
           "COUNT(CASE WHEN cr.status = 'completed' THEN 1 END) * 100.0 / COUNT(cr) " +
           "FROM CourseRegistration cr WHERE cr.course.id = :courseId")
    Double getCompletionRateByCourseId(@Param("courseId") Long courseId);
}
```

## üîÑ LU·ªíNG X·ª¨ L√ù CHI TI·∫æT

### **1. LU·ªíNG T·∫†O KH√ìA H·ªåC M·ªöI**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ STAFF/ADMIN     ‚îÇ
‚îÇ t·∫°o kh√≥a h·ªçc    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ POST /api/courses ho·∫∑c /api/staff/courses
          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ CourseController‚îÇ
‚îÇ - Validate JWT  ‚îÇ
‚îÇ - Check role    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ Course object
          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ CourseService   ‚îÇ
‚îÇ - Validate data ‚îÇ
‚îÇ - Set defaults  ‚îÇ 
‚îÇ - Check category‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ Course entity
          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ CourseRepo      ‚îÇ
‚îÇ - Save to DB    ‚îÇ
‚îÇ - Auto-gen ID   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ Saved Course
          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Response        ‚îÇ
‚îÇ - Course DTO    ‚îÇ
‚îÇ - 201 Created   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Chi ti·∫øt code:**

**Controller Layer:**
```java
@PostMapping
@PreAuthorize("hasAnyRole('STAFF', 'ADMIN', 'MANAGER')")
public ResponseEntity<Course> createCourse(@Valid @RequestBody Course course, 
                                         Authentication authentication) {
    // Get current user info
    String username = authentication.getName();
    User instructor = userService.findByUsername(username);
    
    // Set instructor
    course.setInstructor(instructor);
    
    // Create course
    Course created = courseService.createCourse(course);
    
    return ResponseEntity.status(HttpStatus.CREATED).body(created);
}
```

**Service Layer:**
```java
@Transactional
public Course createCourse(Course course) {
    // 1. Validate course data
    validateCourseData(course);
    
    // 2. Set default values
    course.setCurrentParticipants(0);
    course.setStatus("open");
    course.setIsFeatured(false);
    course.setTotalReviews(0);
    course.setAverageRating(0.0);
    course.setCreatedAt(LocalDateTime.now());
    course.setUpdatedAt(LocalDateTime.now());
    
    // 3. Save course
    Course saved = courseRepository.save(course);
    
    // 4. Create default course structure (optional)
    createDefaultLessons(saved);
    
    // 5. Log activity
    logCourseActivity(saved, "CREATED");
    
    return saved;
}
```

### **2. LU·ªíNG ƒêƒÇNG K√ù KH√ìA H·ªåC**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ User click      ‚îÇ
‚îÇ "ƒêƒÉng k√Ω"       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ POST /api/course-registrations/register/{courseId}
          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Check eligibility‚îÇ
‚îÇ - User exists   ‚îÇ
‚îÇ - Course open   ‚îÇ 
‚îÇ - Not registered‚îÇ
‚îÇ - C√≥ ch·ªó tr·ªëng  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Check payment   ‚îÇ
‚îÇ - Free course ‚Üí ‚îÇ
‚îÇ   Direct active ‚îÇ
‚îÇ - Paid course ‚Üí ‚îÇ
‚îÇ   Pending pay   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Create          ‚îÇ
‚îÇ CourseRegistration‚îÇ
‚îÇ + CourseProgress‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Update course   ‚îÇ
‚îÇ participant count‚îÇ
‚îÇ Send notification‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Chi ti·∫øt implementation:**

```java
@PostMapping("/register/{courseId}")
@PreAuthorize("hasRole('USER')")
public ResponseEntity<CourseRegistration> registerForCourse(
    @PathVariable Long courseId,
    Authentication authentication) {
    
    String username = authentication.getName();
    
    try {
        CourseRegistration registration = courseRegistrationService
            .registerForCourse(courseId, username);
        return ResponseEntity.ok(registration);
    } catch (RuntimeException e) {
        return ResponseEntity.badRequest().build();
    }
}
```

### **3. LU·ªíNG THANH TO√ÅN VNPAY**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ User ƒëƒÉng k√Ω    ‚îÇ
‚îÇ paid course     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Create Payment  ‚îÇ
‚îÇ entity v·ªõi      ‚îÇ
‚îÇ status PENDING  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Generate VNPay  ‚îÇ
‚îÇ payment URL     ‚îÇ
‚îÇ redirect user   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ User pays on    ‚îÇ
‚îÇ VNPay portal    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ VNPay callback  ‚îÇ
‚îÇ /api/payment/   ‚îÇ
‚îÇ vnpay-callback  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Update Payment  ‚îÇ
‚îÇ status & Course ‚îÇ
‚îÇ Registration    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üí≥ T√çCH H·ª¢P VNPAY PAYMENT

### **Payment Entity:**
```java
@Entity
public class Payment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
    
    @OneToOne(mappedBy = "payment")
    private CourseRegistration courseRegistration;
    
    private BigDecimal amount;
    private String currency = "VND";
    private String status; // PENDING/COMPLETED/FAILED/CANCELLED
    private String paymentMethod = "VNPAY";
    
    private String vnpTransactionId;
    private String vnpOrderInfo;
    private LocalDateTime paymentDate;
    private LocalDateTime createdAt;
}
```

### **VNPay Service Integration:**
```java
@Service
public class VnPayService {
    
    public String createPaymentUrl(CourseRegistration registration, HttpServletRequest request) {
        // 1. Build payment parameters
        Map<String, String> vnpParams = new HashMap<>();
        vnpParams.put("vnp_Version", "2.1.0");
        vnpParams.put("vnp_Command", "pay");
        vnpParams.put("vnp_TmnCode", vnpTmnCode);
        vnpParams.put("vnp_Amount", String.valueOf(registration.getCourse().getPrice().multiply(new BigDecimal(100)).longValue()));
        vnpParams.put("vnp_CurrCode", "VND");
        vnpParams.put("vnp_TxnRef", "COURSE_" + registration.getCourse().getId() + "_" + System.currentTimeMillis());
        vnpParams.put("vnp_OrderInfo", "Thanh toan khoa hoc: " + registration.getCourse().getTitle());
        vnpParams.put("vnp_OrderType", "other");
        vnpParams.put("vnp_ReturnUrl", vnpReturnUrl);
        vnpParams.put("vnp_IpAddr", getClientIpAddress(request));
        vnpParams.put("vnp_CreateDate", new SimpleDateFormat("yyyyMMddHHmmss").format(new Date()));
        
        // 2. Build URL v·ªõi signature
        return buildPaymentUrl(vnpParams);
    }
    
    public boolean validateCallback(Map<String, String> params) {
        // Validate VNPay signature
        String receivedHash = params.get("vnp_SecureHash");
        String calculatedHash = calculateHash(params);
        
        return receivedHash.equals(calculatedHash) && 
               "00".equals(params.get("vnp_ResponseCode"));
    }
}
```

## üîê SECURITY & VALIDATION

### **Course Access Control:**
```java
// Trong CourseController
@PreAuthorize("hasAnyRole('STAFF', 'ADMIN', 'MANAGER')")    // Create/Update
@PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")            // Delete
@PreAuthorize("@courseService.isInstructor(#id, authentication.name)")  // Update own course

// Trong CourseRegistrationController  
@PreAuthorize("hasRole('USER')")                           // Register for course
@PreAuthorize("@courseRegistrationService.isOwner(#id, authentication.name)")  // Update progress
```

### **Business Validation:**
```java
private void validateCourseRegistration(User user, Course course) {
    // 1. Course must be open
    if (!"open".equals(course.getStatus())) {
        throw new BusinessException("Course is not available for registration");
    }
    
    // 2. Check capacity
    if (course.getCurrentParticipants() >= course.getMaxParticipants()) {
        throw new BusinessException("Course is full");
    }
    
    // 3. Check prerequisites (if any)
    if (!hasPrerequisites(user, course)) {
        throw new BusinessException("User does not meet prerequisites");
    }
    
    // 4. Check duplicate registration
    if (courseRegistrationRepository.findByUserIdAndCourseId(user.getId(), course.getId()).isPresent()) {
        throw new BusinessException("User already registered for this course");
    }
}
```

## üìä STATISTICS & REPORTING

### **Course Statistics:**
```java
@Service
public class CourseStatisticsService {
    
    public CourseStatisticsDTO getCourseStatistics(Long courseId) {
        Course course = courseRepository.findById(courseId)
            .orElseThrow(() -> new RuntimeException("Course not found"));
        
        // Basic stats
        Long totalRegistrations = courseRegistrationRepository.countByCourseId(courseId);
        Long activeStudents = courseRegistrationRepository.countByCourseIdAndStatus(courseId, "active");
        Long completedStudents = courseRegistrationRepository.countByCourseIdAndStatus(courseId, "completed");
        
        // Completion rate
        Double completionRate = courseRegistrationRepository.getCompletionRateByCourseId(courseId);
        
        // Revenue calculation
        BigDecimal totalRevenue = calculateCourseRevenue(courseId);
        
        // Daily registration trends
        List<Object[]> registrationTrends = courseRegistrationRepository
            .getRegistrationStatsByDate(courseId, LocalDateTime.now().minusDays(30));
        
        return CourseStatisticsDTO.builder()
            .courseId(courseId)
            .totalRegistrations(totalRegistrations)
            .activeStudents(activeStudents)
            .completedStudents(completedStudents)
            .completionRate(completionRate)
            .totalRevenue(totalRevenue)
            .registrationTrends(registrationTrends)
            .build();
    }
}
```

## üß™ TESTING GUIDELINES

### **Unit Tests:**
```java
@ExtendWith(MockitoExtension.class)
class CourseServiceTest {
    
    @Mock
    private CourseRepository courseRepository;
    
    @Mock  
    private CategoryRepository categoryRepository;
    
    @InjectMocks
    private CourseService courseService;
    
    @Test
    void createCourse_ValidData_Success() {
        // Given
        Course course = new Course();
        course.setTitle("Test Course");
        course.setPrice(new BigDecimal("500000"));
        course.setMaxParticipants(20);
        
        when(courseRepository.save(any(Course.class))).thenReturn(course);
        
        // When
        Course result = courseService.createCourse(course);
        
        // Then
        assertThat(result.getCurrentParticipants()).isEqualTo(0);
        assertThat(result.getStatus()).isEqualTo("open");
        assertThat(result.getIsFeatured()).isFalse();
        verify(courseRepository).save(any(Course.class));
    }
    
    @Test
    void createCourse_InvalidPrice_ThrowsException() {
        // Given
        Course course = new Course();
        course.setTitle("Test Course");
        course.setPrice(new BigDecimal("-100"));
        
        // When & Then
        assertThrows(ValidationException.class, () -> {
            courseService.createCourse(course);
        });
    }
}
```

### **Integration Tests:**
```java
@SpringBootTest
@Transactional
class CourseRegistrationIntegrationTest {
    
    @Autowired
    private CourseRegistrationService courseRegistrationService;
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Test
    void registerForCourse_FreeeCourse_Success() {
        // Given
        User user = createTestUser();
        Course course = createTestCourse(BigDecimal.ZERO); // Free course
        entityManager.persistAndFlush(user);
        entityManager.persistAndFlush(course);
        
        // When
        CourseRegistration registration = courseRegistrationService
            .registerForCourse(course.getId(), user.getUsername());
        
        // Then
        assertThat(registration.getStatus()).isEqualTo("active");
        assertThat(registration.getProgress()).isEqualTo(0);
        assertThat(registration.getPayment()).isNull();
    }
    
    @Test
    void registerForCourse_PaidCourse_PendingPayment() {
        // Given
        User user = createTestUser();
        Course course = createTestCourse(new BigDecimal("500000")); // Paid course
        entityManager.persistAndFlush(user);
        entityManager.persistAndFlush(course);
        
        // When
        CourseRegistration registration = courseRegistrationService
            .registerForCourse(course.getId(), user.getUsername());
        
        // Then
        assertThat(registration.getStatus()).isEqualTo("pending_payment");
        assertThat(registration.getPayment()).isNotNull();
        assertThat(registration.getPayment().getStatus()).isEqualTo("PENDING");
    }
}
```

## üìà PERFORMANCE OPTIMIZATION

### **Database Indexing:**
```sql
-- Course table indexes
CREATE INDEX idx_courses_category_id ON courses(category_id);
CREATE INDEX idx_courses_instructor_id ON courses(instructor_id);
CREATE INDEX idx_courses_status ON courses(status);
CREATE INDEX idx_courses_price ON courses(price);
CREATE INDEX idx_courses_featured ON courses(is_featured);
CREATE INDEX idx_courses_created_at ON courses(created_at);

-- Course Registration indexes  
CREATE INDEX idx_course_registrations_user_id ON course_registrations(user_id);
CREATE INDEX idx_course_registrations_course_id ON course_registrations(course_id);
CREATE INDEX idx_course_registrations_status ON course_registrations(status);
CREATE INDEX idx_course_registrations_registration_date ON course_registrations(registration_date);

-- Course Content indexes
CREATE INDEX idx_course_contents_course_id ON course_contents(course_id);
CREATE INDEX idx_course_contents_order_index ON course_contents(order_index);
```

### **Caching Strategy:**
```java
// Cache course list
@Cacheable(value = "courses", key = "'all-' + #status")
public List<Course> getAllCoursesByStatus(String status) {
    return courseRepository.findByStatusOrderByCreatedAtDesc(status);
}

// Cache course details
@Cacheable(value = "course-details", key = "#id")
public Course getCourseById(Long id) {
    return courseRepository.findById(id)
        .orElseThrow(() -> new RuntimeException("Course not found"));
}

// Cache featured courses
@Cacheable(value = "featured-courses", key = "'featured'")
public List<Course> getFeaturedCourses() {
    return courseRepository.findByIsFeaturedTrueAndStatusOrderByCreatedAtDesc("open");
}

// Evict cache khi update
@CacheEvict(value = {"courses", "course-details", "featured-courses"}, allEntries = true)
public Course updateCourse(Long id, Course courseUpdate) {
    // Update logic
}
```

## üéØ NEXT STEPS & IMPROVEMENTS

1. **Live streaming** cho kh√≥a h·ªçc tr·ª±c tuy·∫øn
2. **AI recommendation** kh√≥a h·ªçc ph√π h·ª£p
3. **Mobile app** v·ªõi offline content
4. **Gamification** (points, badges, leaderboard)
5. **Advanced analytics** v√† reporting
6. **Multi-language support**
7. **Course marketplace** v·ªõi revenue sharing

---

**üî• L·ªúI KHUY√äN QUAN TR·ªåNG:**
- Lu√¥n validate payment status tr∆∞·ªõc khi activate course
- Monitor VNPay callback errors v√† retry mechanism
- Cache heavily-accessed course data
- Implement proper file upload cho course materials
- Track user engagement metrics chi ti·∫øt
- Backup strategy cho course content v√† user progress 